<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Meazure: ev::ParseNode Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Meazure
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceev.html">ev</a></li><li class="navelem"><a class="el" href="classev_1_1ParseNode.html">ParseNode</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classev_1_1ParseNode-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ev::ParseNode Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Represents a node in the parse tree that is constructed by parsing the content model.  
 <a href="classev_1_1ParseNode.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structev_1_1ParseNode_1_1LessOp.html">LessOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used by STL to compare two <a class="el" href="classev_1_1ParseNode.html" title="Represents a node in the parse tree that is constructed by parsing the content model.">ParseNode</a> objects.  <a href="structev_1_1ParseNode_1_1LessOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a5033886db86b646a9ac1f20d8ff37dcb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#a5033886db86b646a9ac1f20d8ff37dcb">Type</a> { <br />
&#160;&#160;<a class="el" href="classev_1_1ParseNode.html#a5033886db86b646a9ac1f20d8ff37dcbaffc2ef17f08dffb49931ae492115eec4">End</a>
, <br />
&#160;&#160;<a class="el" href="classev_1_1ParseNode.html#a5033886db86b646a9ac1f20d8ff37dcba571be90a20298fd4ca9b33113caefb06">Epsilon</a>
, <br />
&#160;&#160;<a class="el" href="classev_1_1ParseNode.html#a5033886db86b646a9ac1f20d8ff37dcbac59f55ecc129026bd3f81d10e103c787">Name</a>
, <br />
&#160;&#160;<a class="el" href="classev_1_1ParseNode.html#a5033886db86b646a9ac1f20d8ff37dcba8321db25fae1552e3d91a8fc63174d85">Choice</a>
, <br />
&#160;&#160;<a class="el" href="classev_1_1ParseNode.html#a5033886db86b646a9ac1f20d8ff37dcba764ec27bdd978f3d500d6c724dc7aed0">Seq</a>
, <br />
&#160;&#160;<a class="el" href="classev_1_1ParseNode.html#a5033886db86b646a9ac1f20d8ff37dcba4c2237d82f94032a6d2ca15490af4e17">Rep</a>
, <br />
&#160;&#160;<a class="el" href="classev_1_1ParseNode.html#a5033886db86b646a9ac1f20d8ff37dcba428ec16d0c0757c93debc2fd1db70515">Opt</a>
, <br />
&#160;&#160;<a class="el" href="classev_1_1ParseNode.html#a5033886db86b646a9ac1f20d8ff37dcba62c057b0e6b727223f79d2ffacb59f91">Plus</a>
<br />
 }</td></tr>
<tr class="memdesc:a5033886db86b646a9ac1f20d8ff37dcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the parse node.  <a href="classev_1_1ParseNode.html#a5033886db86b646a9ac1f20d8ff37dcb">More...</a><br /></td></tr>
<tr class="separator:a5033886db86b646a9ac1f20d8ff37dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f2bac801675232374915968e477770a"><td class="memItemLeft" align="right" valign="top"><a id="a2f2bac801675232374915968e477770a" name="a2f2bac801675232374915968e477770a"></a>
typedef std::set&lt; <a class="el" href="classev_1_1ParseNode.html">ParseNode</a> *, <a class="el" href="structev_1_1ParseNode_1_1LessOp.html">LessOp</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>NodeSet</b></td></tr>
<tr class="memdesc:a2f2bac801675232374915968e477770a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of parse nodes. <br /></td></tr>
<tr class="separator:a2f2bac801675232374915968e477770a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c1f4f84c399d876da87cd499cb8e70a"><td class="memItemLeft" align="right" valign="top"><a id="a9c1f4f84c399d876da87cd499cb8e70a" name="a9c1f4f84c399d876da87cd499cb8e70a"></a>
typedef NodeSet::iterator&#160;</td><td class="memItemRight" valign="bottom"><b>NodeIter</b></td></tr>
<tr class="memdesc:a9c1f4f84c399d876da87cd499cb8e70a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over a set of parse nodes. <br /></td></tr>
<tr class="separator:a9c1f4f84c399d876da87cd499cb8e70a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f6bb58e423e9e48f0073ca806319e9"><td class="memItemLeft" align="right" valign="top"><a id="a85f6bb58e423e9e48f0073ca806319e9" name="a85f6bb58e423e9e48f0073ca806319e9"></a>
typedef NodeSet::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>NodeIter_c</b></td></tr>
<tr class="memdesc:a85f6bb58e423e9e48f0073ca806319e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant iterator over a set of parse nodes. <br /></td></tr>
<tr class="separator:a85f6bb58e423e9e48f0073ca806319e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab160ce1585e0e6c880297f573d5cbf6f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#ab160ce1585e0e6c880297f573d5cbf6f">ParseNode</a> (<a class="el" href="classev_1_1ParseNode.html#a5033886db86b646a9ac1f20d8ff37dcb">Type</a> type)</td></tr>
<tr class="memdesc:ab160ce1585e0e6c880297f573d5cbf6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a parse node of the specified type.  <a href="classev_1_1ParseNode.html#ab160ce1585e0e6c880297f573d5cbf6f">More...</a><br /></td></tr>
<tr class="separator:ab160ce1585e0e6c880297f573d5cbf6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a865215af96800eead0937bc3e95b56fe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#a865215af96800eead0937bc3e95b56fe">ParseNode</a> (<a class="el" href="classev_1_1ParseNode.html#a5033886db86b646a9ac1f20d8ff37dcb">Type</a> type, <a class="el" href="classev_1_1ParseNode.html">ParseNode</a> *left)</td></tr>
<tr class="memdesc:a865215af96800eead0937bc3e95b56fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a parse node of the specified type and with the specified left child node.  <a href="classev_1_1ParseNode.html#a865215af96800eead0937bc3e95b56fe">More...</a><br /></td></tr>
<tr class="separator:a865215af96800eead0937bc3e95b56fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0823945f344a5894e00109d29e408d2"><td class="memItemLeft" align="right" valign="top"><a id="ad0823945f344a5894e00109d29e408d2" name="ad0823945f344a5894e00109d29e408d2"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~ParseNode</b> ()</td></tr>
<tr class="memdesc:ad0823945f344a5894e00109d29e408d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a parse node instance. <br /></td></tr>
<tr class="separator:ad0823945f344a5894e00109d29e408d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51610ec93b6d3be6a77f429240bc2bfc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classev_1_1ParseNode.html">ParseNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#a51610ec93b6d3be6a77f429240bc2bfc">CloneType</a> () const</td></tr>
<tr class="memdesc:a51610ec93b6d3be6a77f429240bc2bfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a copy of this node.  <a href="classev_1_1ParseNode.html#a51610ec93b6d3be6a77f429240bc2bfc">More...</a><br /></td></tr>
<tr class="separator:a51610ec93b6d3be6a77f429240bc2bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa02d149c0e755b9206a1d7a3fe88ec12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classev_1_1ParseNode.html#a5033886db86b646a9ac1f20d8ff37dcb">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#aa02d149c0e755b9206a1d7a3fe88ec12">GetType</a> () const</td></tr>
<tr class="memdesc:aa02d149c0e755b9206a1d7a3fe88ec12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type of the parse node.  <a href="classev_1_1ParseNode.html#aa02d149c0e755b9206a1d7a3fe88ec12">More...</a><br /></td></tr>
<tr class="separator:aa02d149c0e755b9206a1d7a3fe88ec12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c347d9c9388e25abae76d17339ef9b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#ae0c347d9c9388e25abae76d17339ef9b">IsEnd</a> () const</td></tr>
<tr class="memdesc:ae0c347d9c9388e25abae76d17339ef9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the node is a terminal node.  <a href="classev_1_1ParseNode.html#ae0c347d9c9388e25abae76d17339ef9b">More...</a><br /></td></tr>
<tr class="separator:ae0c347d9c9388e25abae76d17339ef9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e192532cdf2b0f540d11c45cd534fe7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#a6e192532cdf2b0f540d11c45cd534fe7">IsEpsilon</a> () const</td></tr>
<tr class="memdesc:a6e192532cdf2b0f540d11c45cd534fe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the node is an any input node.  <a href="classev_1_1ParseNode.html#a6e192532cdf2b0f540d11c45cd534fe7">More...</a><br /></td></tr>
<tr class="separator:a6e192532cdf2b0f540d11c45cd534fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6e8e9459da88cb7adcfc2eb61584dfd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#ae6e8e9459da88cb7adcfc2eb61584dfd">IsName</a> () const</td></tr>
<tr class="memdesc:ae6e8e9459da88cb7adcfc2eb61584dfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the node contains an element name.  <a href="classev_1_1ParseNode.html#ae6e8e9459da88cb7adcfc2eb61584dfd">More...</a><br /></td></tr>
<tr class="separator:ae6e8e9459da88cb7adcfc2eb61584dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0430dd0dcbbb5111756bce2e0b759b56"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#a0430dd0dcbbb5111756bce2e0b759b56">IsChoice</a> () const</td></tr>
<tr class="memdesc:a0430dd0dcbbb5111756bce2e0b759b56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the node is an OR'd choice node.  <a href="classev_1_1ParseNode.html#a0430dd0dcbbb5111756bce2e0b759b56">More...</a><br /></td></tr>
<tr class="separator:a0430dd0dcbbb5111756bce2e0b759b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00c78f9383bfe16f2b98888e551611c0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#a00c78f9383bfe16f2b98888e551611c0">IsSeq</a> () const</td></tr>
<tr class="memdesc:a00c78f9383bfe16f2b98888e551611c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the node is a sequence node.  <a href="classev_1_1ParseNode.html#a00c78f9383bfe16f2b98888e551611c0">More...</a><br /></td></tr>
<tr class="separator:a00c78f9383bfe16f2b98888e551611c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7943bf5f0dc0a2977ea73f65c3e5e88f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#a7943bf5f0dc0a2977ea73f65c3e5e88f">IsRep</a> () const</td></tr>
<tr class="memdesc:a7943bf5f0dc0a2977ea73f65c3e5e88f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the cardinality of the node is zero of more.  <a href="classev_1_1ParseNode.html#a7943bf5f0dc0a2977ea73f65c3e5e88f">More...</a><br /></td></tr>
<tr class="separator:a7943bf5f0dc0a2977ea73f65c3e5e88f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22f145091ed8fcf6b0a1f31f99f730de"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#a22f145091ed8fcf6b0a1f31f99f730de">IsOpt</a> () const</td></tr>
<tr class="memdesc:a22f145091ed8fcf6b0a1f31f99f730de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the cardinality of the node is zero or one.  <a href="classev_1_1ParseNode.html#a22f145091ed8fcf6b0a1f31f99f730de">More...</a><br /></td></tr>
<tr class="separator:a22f145091ed8fcf6b0a1f31f99f730de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcd6f364e6712231939f92e48e90b5ee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#adcd6f364e6712231939f92e48e90b5ee">IsPlus</a> () const</td></tr>
<tr class="memdesc:adcd6f364e6712231939f92e48e90b5ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the cardinality of the node is one or more.  <a href="classev_1_1ParseNode.html#adcd6f364e6712231939f92e48e90b5ee">More...</a><br /></td></tr>
<tr class="separator:adcd6f364e6712231939f92e48e90b5ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4a71198378973cbfa81e93db4206550"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#ac4a71198378973cbfa81e93db4206550">HaveLeft</a> () const</td></tr>
<tr class="memdesc:ac4a71198378973cbfa81e93db4206550"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether this node has a child on its left branch.  <a href="classev_1_1ParseNode.html#ac4a71198378973cbfa81e93db4206550">More...</a><br /></td></tr>
<tr class="separator:ac4a71198378973cbfa81e93db4206550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eddf65d3e9d8cb326f8bcc7308bf47f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#a7eddf65d3e9d8cb326f8bcc7308bf47f">HaveRight</a> () const</td></tr>
<tr class="memdesc:a7eddf65d3e9d8cb326f8bcc7308bf47f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether this node has a child on its right branch.  <a href="classev_1_1ParseNode.html#a7eddf65d3e9d8cb326f8bcc7308bf47f">More...</a><br /></td></tr>
<tr class="separator:a7eddf65d3e9d8cb326f8bcc7308bf47f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d4dace3f9cedc110edee0de3641e73d"><td class="memItemLeft" align="right" valign="top"><a id="a0d4dace3f9cedc110edee0de3641e73d" name="a0d4dace3f9cedc110edee0de3641e73d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetLeft</b> (<a class="el" href="classev_1_1ParseNode.html">ParseNode</a> *node)</td></tr>
<tr class="memdesc:a0d4dace3f9cedc110edee0de3641e73d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the specified parse node as the left side child of this node. <br /></td></tr>
<tr class="separator:a0d4dace3f9cedc110edee0de3641e73d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88fb81164cfcf0d0af6da0babbafa87c"><td class="memItemLeft" align="right" valign="top"><a id="a88fb81164cfcf0d0af6da0babbafa87c" name="a88fb81164cfcf0d0af6da0babbafa87c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetRight</b> (<a class="el" href="classev_1_1ParseNode.html">ParseNode</a> *node)</td></tr>
<tr class="memdesc:a88fb81164cfcf0d0af6da0babbafa87c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the specified parse node as the right side child of this node. <br /></td></tr>
<tr class="separator:a88fb81164cfcf0d0af6da0babbafa87c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e530a7def720627e7eb03019880211b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classev_1_1ParseNode.html">ParseNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#a8e530a7def720627e7eb03019880211b">GetLeft</a> () const</td></tr>
<tr class="memdesc:a8e530a7def720627e7eb03019880211b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the left branch child node of this node.  <a href="classev_1_1ParseNode.html#a8e530a7def720627e7eb03019880211b">More...</a><br /></td></tr>
<tr class="separator:a8e530a7def720627e7eb03019880211b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18306cd056264f5a5f7242dd93eb57de"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classev_1_1ParseNode.html">ParseNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#a18306cd056264f5a5f7242dd93eb57de">GetRight</a> () const</td></tr>
<tr class="memdesc:a18306cd056264f5a5f7242dd93eb57de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the right branch child node of this node.  <a href="classev_1_1ParseNode.html#a18306cd056264f5a5f7242dd93eb57de">More...</a><br /></td></tr>
<tr class="separator:a18306cd056264f5a5f7242dd93eb57de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a121cd27ac3fc7845beb169d746e4fd3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classev_1_1ParseNode.html">ParseNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#a121cd27ac3fc7845beb169d746e4fd3d">GetRight</a> ()</td></tr>
<tr class="memdesc:a121cd27ac3fc7845beb169d746e4fd3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the right branch child node of this node.  <a href="classev_1_1ParseNode.html#a121cd27ac3fc7845beb169d746e4fd3d">More...</a><br /></td></tr>
<tr class="separator:a121cd27ac3fc7845beb169d746e4fd3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d15e193e545b517398791b8fd97642c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#a9d15e193e545b517398791b8fd97642c">SetSymbol</a> (const XML_Char *symbol)</td></tr>
<tr class="memdesc:a9d15e193e545b517398791b8fd97642c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the input symbol for this parse node.  <a href="classev_1_1ParseNode.html#a9d15e193e545b517398791b8fd97642c">More...</a><br /></td></tr>
<tr class="separator:a9d15e193e545b517398791b8fd97642c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44a46bc16d660ff09e8649a1ccb9161f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#a44a46bc16d660ff09e8649a1ccb9161f">SetSymbol</a> (const <a class="el" href="namespaceev.html#a6efc98031badec1ea51620e17b011892">EVString</a> &amp;symbol)</td></tr>
<tr class="memdesc:a44a46bc16d660ff09e8649a1ccb9161f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the input symbol for this parse node.  <a href="classev_1_1ParseNode.html#a44a46bc16d660ff09e8649a1ccb9161f">More...</a><br /></td></tr>
<tr class="separator:a44a46bc16d660ff09e8649a1ccb9161f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a3cba74a4c368f215fd3d6d5ff928ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceev.html#a6efc98031badec1ea51620e17b011892">EVString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#a9a3cba74a4c368f215fd3d6d5ff928ab">GetSymbol</a> () const</td></tr>
<tr class="memdesc:a9a3cba74a4c368f215fd3d6d5ff928ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the input symbol for this parse node.  <a href="classev_1_1ParseNode.html#a9a3cba74a4c368f215fd3d6d5ff928ab">More...</a><br /></td></tr>
<tr class="separator:a9a3cba74a4c368f215fd3d6d5ff928ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29416f4a095efa92cf20740539dc855f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#a29416f4a095efa92cf20740539dc855f">GetSymbolSet</a> (<a class="el" href="namespaceev.html#ae2a90caa1b9395bf42edb2f451535c84">SymbolSet</a> &amp;symbols) const</td></tr>
<tr class="memdesc:a29416f4a095efa92cf20740539dc855f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the specified set with the input symbols for the parse tree.  <a href="classev_1_1ParseNode.html#a29416f4a095efa92cf20740539dc855f">More...</a><br /></td></tr>
<tr class="separator:a29416f4a095efa92cf20740539dc855f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a00aab8be63bfa3dfb44b8e026d8fad"><td class="memItemLeft" align="right" valign="top"><a id="a5a00aab8be63bfa3dfb44b8e026d8fad" name="a5a00aab8be63bfa3dfb44b8e026d8fad"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>BuildFollowpos</b> ()</td></tr>
<tr class="memdesc:a5a00aab8be63bfa3dfb44b8e026d8fad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pre-constructs the followpos function as described in section 3.9 of the Dragon book. <br /></td></tr>
<tr class="separator:a5a00aab8be63bfa3dfb44b8e026d8fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a8f0b480acb3b897c68d4b297b679f7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#a5a8f0b480acb3b897c68d4b297b679f7">GetId</a> () const</td></tr>
<tr class="memdesc:a5a8f0b480acb3b897c68d4b297b679f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ID of this parse node.  <a href="classev_1_1ParseNode.html#a5a8f0b480acb3b897c68d4b297b679f7">More...</a><br /></td></tr>
<tr class="separator:a5a8f0b480acb3b897c68d4b297b679f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d1792be6ea38217372a9ee5cd81fb1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classev_1_1ParseNode.html#a2f2bac801675232374915968e477770a">NodeSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#a21d1792be6ea38217372a9ee5cd81fb1">GetFirstpos</a> () const</td></tr>
<tr class="memdesc:a21d1792be6ea38217372a9ee5cd81fb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the nodes that comprise the firstpos() set as defined in section 3.9 of the Dragon book.  <a href="classev_1_1ParseNode.html#a21d1792be6ea38217372a9ee5cd81fb1">More...</a><br /></td></tr>
<tr class="separator:a21d1792be6ea38217372a9ee5cd81fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac184e45771646e7efc9b7bc6453a83dd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classev_1_1ParseNode.html#a2f2bac801675232374915968e477770a">NodeSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#ac184e45771646e7efc9b7bc6453a83dd">GetFollowpos</a> () const</td></tr>
<tr class="memdesc:ac184e45771646e7efc9b7bc6453a83dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the nodes that comprise the followpos() set as defined in section 3.9 of the Dragon book.  <a href="classev_1_1ParseNode.html#ac184e45771646e7efc9b7bc6453a83dd">More...</a><br /></td></tr>
<tr class="separator:ac184e45771646e7efc9b7bc6453a83dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ae5fa3860607dbb77464dcd6a2b4659f0"><td class="memItemLeft" align="right" valign="top"><a id="ae5fa3860607dbb77464dcd6a2b4659f0" name="ae5fa3860607dbb77464dcd6a2b4659f0"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>ResetId</b> ()</td></tr>
<tr class="memdesc:ae5fa3860607dbb77464dcd6a2b4659f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the ID assigned to the parse nodes. <br /></td></tr>
<tr class="separator:ae5fa3860607dbb77464dcd6a2b4659f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a327f32856c218056887aac463f01fee0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#a327f32856c218056887aac463f01fee0">Union</a> (<a class="el" href="classev_1_1ParseNode.html#a2f2bac801675232374915968e477770a">NodeSet</a> &amp;set1, const <a class="el" href="classev_1_1ParseNode.html#a2f2bac801675232374915968e477770a">NodeSet</a> &amp;set2)</td></tr>
<tr class="memdesc:a327f32856c218056887aac463f01fee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a set union on the two specified sets of nodes.  <a href="classev_1_1ParseNode.html#a327f32856c218056887aac463f01fee0">More...</a><br /></td></tr>
<tr class="separator:a327f32856c218056887aac463f01fee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b8b076e4ff3895f9716185c392a9c6"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#a50b8b076e4ff3895f9716185c392a9c6">EqualOp</a> (const <a class="el" href="classev_1_1ParseNode.html">ParseNode</a> *n1, const <a class="el" href="classev_1_1ParseNode.html">ParseNode</a> *n2)</td></tr>
<tr class="memdesc:a50b8b076e4ff3895f9716185c392a9c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether the two specified parse nodes are equal.  <a href="classev_1_1ParseNode.html#a50b8b076e4ff3895f9716185c392a9c6">More...</a><br /></td></tr>
<tr class="separator:a50b8b076e4ff3895f9716185c392a9c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a9c9e7dbba71bb671db07d8a325701655"><td class="memItemLeft" align="right" valign="top"><a id="a9c9e7dbba71bb671db07d8a325701655" name="a9c9e7dbba71bb671db07d8a325701655"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ParseNode</b> (const <a class="el" href="classev_1_1ParseNode.html">ParseNode</a> &amp;node)</td></tr>
<tr class="memdesc:a9c9e7dbba71bb671db07d8a325701655"><td class="mdescLeft">&#160;</td><td class="mdescRight">Purposely undefined. <br /></td></tr>
<tr class="separator:a9c9e7dbba71bb671db07d8a325701655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af84bcaa4246dff465bcf0f690bda5183"><td class="memItemLeft" align="right" valign="top"><a id="af84bcaa4246dff465bcf0f690bda5183" name="af84bcaa4246dff465bcf0f690bda5183"></a>
<a class="el" href="classev_1_1ParseNode.html">ParseNode</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classev_1_1ParseNode.html">ParseNode</a> &amp;node)</td></tr>
<tr class="memdesc:af84bcaa4246dff465bcf0f690bda5183"><td class="mdescLeft">&#160;</td><td class="mdescRight">Purposely undefined. <br /></td></tr>
<tr class="separator:af84bcaa4246dff465bcf0f690bda5183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8f27689dc35d3b06237616cbb4cc205"><td class="memItemLeft" align="right" valign="top"><a id="ad8f27689dc35d3b06237616cbb4cc205" name="ad8f27689dc35d3b06237616cbb4cc205"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Nullable</b> ()</td></tr>
<tr class="memdesc:ad8f27689dc35d3b06237616cbb4cc205"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the nullable() function as defined in section 3.9 of the Dragon book. <br /></td></tr>
<tr class="separator:ad8f27689dc35d3b06237616cbb4cc205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a043aec49a1c2e543c546c9cd72d6cc61"><td class="memItemLeft" align="right" valign="top"><a id="a043aec49a1c2e543c546c9cd72d6cc61" name="a043aec49a1c2e543c546c9cd72d6cc61"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Firstpos</b> ()</td></tr>
<tr class="memdesc:a043aec49a1c2e543c546c9cd72d6cc61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the firstpos() function as defined in section 3.9 of the Dragon book. <br /></td></tr>
<tr class="separator:a043aec49a1c2e543c546c9cd72d6cc61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a518da96b98058bcb0b65f156ec7d1f92"><td class="memItemLeft" align="right" valign="top"><a id="a518da96b98058bcb0b65f156ec7d1f92" name="a518da96b98058bcb0b65f156ec7d1f92"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Lastpos</b> ()</td></tr>
<tr class="memdesc:a518da96b98058bcb0b65f156ec7d1f92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the lastpos() function as defined in section 3.9 of the Dragon book. <br /></td></tr>
<tr class="separator:a518da96b98058bcb0b65f156ec7d1f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c7333bbbb36c5d795f11195a7d67dae"><td class="memItemLeft" align="right" valign="top"><a id="a5c7333bbbb36c5d795f11195a7d67dae" name="a5c7333bbbb36c5d795f11195a7d67dae"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Followpos</b> ()</td></tr>
<tr class="memdesc:a5c7333bbbb36c5d795f11195a7d67dae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the followpos() function as defined in section 3.9 of the Dragon book. <br /></td></tr>
<tr class="separator:a5c7333bbbb36c5d795f11195a7d67dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aae3e2c07f86de2697ec17538e2cb2dce"><td class="memItemLeft" align="right" valign="top"><a id="aae3e2c07f86de2697ec17538e2cb2dce" name="aae3e2c07f86de2697ec17538e2cb2dce"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>m_id</b></td></tr>
<tr class="memdesc:aae3e2c07f86de2697ec17538e2cb2dce"><td class="mdescLeft">&#160;</td><td class="mdescRight">ID for this parse node. <br /></td></tr>
<tr class="separator:aae3e2c07f86de2697ec17538e2cb2dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eb6da4a1d7ef54aad3d702e1478674c"><td class="memItemLeft" align="right" valign="top"><a id="a5eb6da4a1d7ef54aad3d702e1478674c" name="a5eb6da4a1d7ef54aad3d702e1478674c"></a>
<a class="el" href="classev_1_1ParseNode.html#a5033886db86b646a9ac1f20d8ff37dcb">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_type</b></td></tr>
<tr class="memdesc:a5eb6da4a1d7ef54aad3d702e1478674c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse node's type. <br /></td></tr>
<tr class="separator:a5eb6da4a1d7ef54aad3d702e1478674c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41d2a504af18d57605f86ca2e39fdf98"><td class="memItemLeft" align="right" valign="top"><a id="a41d2a504af18d57605f86ca2e39fdf98" name="a41d2a504af18d57605f86ca2e39fdf98"></a>
<a class="el" href="classev_1_1ParseNode.html">ParseNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>m_left</b></td></tr>
<tr class="memdesc:a41d2a504af18d57605f86ca2e39fdf98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse node's left child node. <br /></td></tr>
<tr class="separator:a41d2a504af18d57605f86ca2e39fdf98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f60fc8a42bd62e2e8fa9d77be0eaee1"><td class="memItemLeft" align="right" valign="top"><a id="a0f60fc8a42bd62e2e8fa9d77be0eaee1" name="a0f60fc8a42bd62e2e8fa9d77be0eaee1"></a>
<a class="el" href="classev_1_1ParseNode.html">ParseNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>m_right</b></td></tr>
<tr class="memdesc:a0f60fc8a42bd62e2e8fa9d77be0eaee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse node's right child node. <br /></td></tr>
<tr class="separator:a0f60fc8a42bd62e2e8fa9d77be0eaee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52c14d1e491c8ae7b92a8fc3d061aba2"><td class="memItemLeft" align="right" valign="top"><a id="a52c14d1e491c8ae7b92a8fc3d061aba2" name="a52c14d1e491c8ae7b92a8fc3d061aba2"></a>
<a class="el" href="namespaceev.html#a6efc98031badec1ea51620e17b011892">EVString</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_symbol</b></td></tr>
<tr class="memdesc:a52c14d1e491c8ae7b92a8fc3d061aba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input symbol. <br /></td></tr>
<tr class="separator:a52c14d1e491c8ae7b92a8fc3d061aba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d6253e9d47c7343fcdcb2ed22323f1b"><td class="memItemLeft" align="right" valign="top"><a id="a6d6253e9d47c7343fcdcb2ed22323f1b" name="a6d6253e9d47c7343fcdcb2ed22323f1b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_nullable</b></td></tr>
<tr class="memdesc:a6d6253e9d47c7343fcdcb2ed22323f1b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>true</b> if the node is nullable. <br /></td></tr>
<tr class="separator:a6d6253e9d47c7343fcdcb2ed22323f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ac98655dcf276149ddc00bbdf3b9c41"><td class="memItemLeft" align="right" valign="top"><a id="a0ac98655dcf276149ddc00bbdf3b9c41" name="a0ac98655dcf276149ddc00bbdf3b9c41"></a>
<a class="el" href="classev_1_1ParseNode.html#a2f2bac801675232374915968e477770a">NodeSet</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_firstPos</b></td></tr>
<tr class="memdesc:a0ac98655dcf276149ddc00bbdf3b9c41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of nodes that satisfy firstpos() for this node. <br /></td></tr>
<tr class="separator:a0ac98655dcf276149ddc00bbdf3b9c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79c69d338100b5b7545c0cf0bbebd8ee"><td class="memItemLeft" align="right" valign="top"><a id="a79c69d338100b5b7545c0cf0bbebd8ee" name="a79c69d338100b5b7545c0cf0bbebd8ee"></a>
<a class="el" href="classev_1_1ParseNode.html#a2f2bac801675232374915968e477770a">NodeSet</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_lastPos</b></td></tr>
<tr class="memdesc:a79c69d338100b5b7545c0cf0bbebd8ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of nodes that satisfy lastpos() for this node. <br /></td></tr>
<tr class="separator:a79c69d338100b5b7545c0cf0bbebd8ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fd795e3f628cafbe31ff30b5541f156"><td class="memItemLeft" align="right" valign="top"><a id="a2fd795e3f628cafbe31ff30b5541f156" name="a2fd795e3f628cafbe31ff30b5541f156"></a>
<a class="el" href="classev_1_1ParseNode.html#a2f2bac801675232374915968e477770a">NodeSet</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_followPos</b></td></tr>
<tr class="memdesc:a2fd795e3f628cafbe31ff30b5541f156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of nodes that satisfy followpos() for this node. <br /></td></tr>
<tr class="separator:a2fd795e3f628cafbe31ff30b5541f156"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-static-attribs" name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:a9a775e7f1efb1e722564bf642e582af7"><td class="memItemLeft" align="right" valign="top"><a id="a9a775e7f1efb1e722564bf642e582af7" name="a9a775e7f1efb1e722564bf642e582af7"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>m_currentId</b> = 0</td></tr>
<tr class="memdesc:a9a775e7f1efb1e722564bf642e582af7"><td class="mdescLeft">&#160;</td><td class="mdescRight">ID to assign to the parse node created next. <br /></td></tr>
<tr class="separator:a9a775e7f1efb1e722564bf642e582af7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a047268c9eb667741446988964484d934"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceev.html#a4743eb632c73d36a5ebd732f402db521">EVOstream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#a047268c9eb667741446988964484d934">operator&lt;&lt;</a> (<a class="el" href="namespaceev.html#a4743eb632c73d36a5ebd732f402db521">EVOstream</a> &amp;stream, const <a class="el" href="classev_1_1ParseNode.html">ParseNode</a> *node)</td></tr>
<tr class="memdesc:a047268c9eb667741446988964484d934"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output stream operator for a parse node.  <a href="classev_1_1ParseNode.html#a047268c9eb667741446988964484d934">More...</a><br /></td></tr>
<tr class="separator:a047268c9eb667741446988964484d934"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Represents a node in the parse tree that is constructed by parsing the content model. </p>
<p >Creating a parse tree is the first step in creating a <a class="el" href="classev_1_1DFA.html" title="This class represents a deterministic finite state automaton (DFA) (i.e.">DFA</a> for an element's content model. The parse tree is constructed according to the technique presented in algorithm 3.5 from the Dragon book. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a5033886db86b646a9ac1f20d8ff37dcb" name="a5033886db86b646a9ac1f20d8ff37dcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5033886db86b646a9ac1f20d8ff37dcb">&#9670;&nbsp;</a></span>Type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classev_1_1ParseNode.html#a5033886db86b646a9ac1f20d8ff37dcb">ev::ParseNode::Type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of the parse node. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5033886db86b646a9ac1f20d8ff37dcbaffc2ef17f08dffb49931ae492115eec4" name="a5033886db86b646a9ac1f20d8ff37dcbaffc2ef17f08dffb49931ae492115eec4"></a>End&#160;</td><td class="fielddoc"><p >Terminal node. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5033886db86b646a9ac1f20d8ff37dcba571be90a20298fd4ca9b33113caefb06" name="a5033886db86b646a9ac1f20d8ff37dcba571be90a20298fd4ca9b33113caefb06"></a>Epsilon&#160;</td><td class="fielddoc"><p >The any input node. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5033886db86b646a9ac1f20d8ff37dcbac59f55ecc129026bd3f81d10e103c787" name="a5033886db86b646a9ac1f20d8ff37dcbac59f55ecc129026bd3f81d10e103c787"></a>Name&#160;</td><td class="fielddoc"><p >An element name node. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5033886db86b646a9ac1f20d8ff37dcba8321db25fae1552e3d91a8fc63174d85" name="a5033886db86b646a9ac1f20d8ff37dcba8321db25fae1552e3d91a8fc63174d85"></a>Choice&#160;</td><td class="fielddoc"><p >An OR'd choice node. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5033886db86b646a9ac1f20d8ff37dcba764ec27bdd978f3d500d6c724dc7aed0" name="a5033886db86b646a9ac1f20d8ff37dcba764ec27bdd978f3d500d6c724dc7aed0"></a>Seq&#160;</td><td class="fielddoc"><p >A sequence node. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5033886db86b646a9ac1f20d8ff37dcba4c2237d82f94032a6d2ca15490af4e17" name="a5033886db86b646a9ac1f20d8ff37dcba4c2237d82f94032a6d2ca15490af4e17"></a>Rep&#160;</td><td class="fielddoc"><p >A zero or more node. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5033886db86b646a9ac1f20d8ff37dcba428ec16d0c0757c93debc2fd1db70515" name="a5033886db86b646a9ac1f20d8ff37dcba428ec16d0c0757c93debc2fd1db70515"></a>Opt&#160;</td><td class="fielddoc"><p >A zero or one node. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5033886db86b646a9ac1f20d8ff37dcba62c057b0e6b727223f79d2ffacb59f91" name="a5033886db86b646a9ac1f20d8ff37dcba62c057b0e6b727223f79d2ffacb59f91"></a>Plus&#160;</td><td class="fielddoc"><p >A one or mode node. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab160ce1585e0e6c880297f573d5cbf6f" name="ab160ce1585e0e6c880297f573d5cbf6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab160ce1585e0e6c880297f573d5cbf6f">&#9670;&nbsp;</a></span>ParseNode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ParseNode::ParseNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classev_1_1ParseNode.html#a5033886db86b646a9ac1f20d8ff37dcb">Type</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a parse node of the specified type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>[in] Parse node type. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="classev_1_1ParseNode.html#a51610ec93b6d3be6a77f429240bc2bfc">CloneType()</a>.</p>

</div>
</div>
<a id="a865215af96800eead0937bc3e95b56fe" name="a865215af96800eead0937bc3e95b56fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a865215af96800eead0937bc3e95b56fe">&#9670;&nbsp;</a></span>ParseNode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ParseNode::ParseNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classev_1_1ParseNode.html#a5033886db86b646a9ac1f20d8ff37dcb">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classev_1_1ParseNode.html">ParseNode</a> *&#160;</td>
          <td class="paramname"><em>left</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a parse node of the specified type and with the specified left child node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>[in] Parse node type. </td></tr>
    <tr><td class="paramname">left</td><td>[in] Left child node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a51610ec93b6d3be6a77f429240bc2bfc" name="a51610ec93b6d3be6a77f429240bc2bfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51610ec93b6d3be6a77f429240bc2bfc">&#9670;&nbsp;</a></span>CloneType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classev_1_1ParseNode.html">ParseNode</a> * ev::ParseNode::CloneType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a copy of this node. </p>
<dl class="section return"><dt>Returns</dt><dd>Copy of this node. </dd></dl>

<p class="reference">References <a class="el" href="classev_1_1ParseNode.html#a5eb6da4a1d7ef54aad3d702e1478674c">m_type</a>, and <a class="el" href="classev_1_1ParseNode.html#ab160ce1585e0e6c880297f573d5cbf6f">ParseNode()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classev_1_1DFA.html#aa0c6f2f5cf6f58b2bf2f92ad15cda426">ev::DFA::BuildParseTree()</a>.</p>

</div>
</div>
<a id="a50b8b076e4ff3895f9716185c392a9c6" name="a50b8b076e4ff3895f9716185c392a9c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50b8b076e4ff3895f9716185c392a9c6">&#9670;&nbsp;</a></span>EqualOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ev::ParseNode::EqualOp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classev_1_1ParseNode.html">ParseNode</a> *&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classev_1_1ParseNode.html">ParseNode</a> *&#160;</td>
          <td class="paramname"><em>n2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether the two specified parse nodes are equal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n1</td><td>[in] First parse node </td></tr>
    <tr><td class="paramname">n2</td><td>[in] Second parse node</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if n1's ID == n2's ID. </dd></dl>

<p class="reference">References <a class="el" href="classev_1_1ParseNode.html#a5a8f0b480acb3b897c68d4b297b679f7">GetId()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classev_1_1State.html#ad856a0091a576c2b2dcbf7a6e1818cec">ev::State::operator==()</a>.</p>

</div>
</div>
<a id="a21d1792be6ea38217372a9ee5cd81fb1" name="a21d1792be6ea38217372a9ee5cd81fb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21d1792be6ea38217372a9ee5cd81fb1">&#9670;&nbsp;</a></span>GetFirstpos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classev_1_1ParseNode.html#a2f2bac801675232374915968e477770a">NodeSet</a> &amp; ev::ParseNode::GetFirstpos </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the nodes that comprise the firstpos() set as defined in section 3.9 of the Dragon book. </p>
<dl class="section return"><dt>Returns</dt><dd>Set of nodes comprising the firstpos() set. </dd></dl>

<p class="reference">References <a class="el" href="classev_1_1ParseNode.html#a0ac98655dcf276149ddc00bbdf3b9c41">m_firstPos</a>.</p>

<p class="reference">Referenced by <a class="el" href="classev_1_1DFA.html#a71e4eab1eda1338b96b160dc03e89e3a">ev::DFA::BuildComplexDFA()</a>.</p>

</div>
</div>
<a id="ac184e45771646e7efc9b7bc6453a83dd" name="ac184e45771646e7efc9b7bc6453a83dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac184e45771646e7efc9b7bc6453a83dd">&#9670;&nbsp;</a></span>GetFollowpos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classev_1_1ParseNode.html#a2f2bac801675232374915968e477770a">NodeSet</a> &amp; ev::ParseNode::GetFollowpos </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the nodes that comprise the followpos() set as defined in section 3.9 of the Dragon book. </p>
<dl class="section return"><dt>Returns</dt><dd>Set of nodes comprising the followpos() set. </dd></dl>

<p class="reference">References <a class="el" href="classev_1_1ParseNode.html#a2fd795e3f628cafbe31ff30b5541f156">m_followPos</a>.</p>

</div>
</div>
<a id="a5a8f0b480acb3b897c68d4b297b679f7" name="a5a8f0b480acb3b897c68d4b297b679f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a8f0b480acb3b897c68d4b297b679f7">&#9670;&nbsp;</a></span>GetId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ev::ParseNode::GetId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the ID of this parse node. </p>
<dl class="section return"><dt>Returns</dt><dd>ID of this parse node. </dd></dl>

<p class="reference">References <a class="el" href="classev_1_1ParseNode.html#aae3e2c07f86de2697ec17538e2cb2dce">m_id</a>.</p>

<p class="reference">Referenced by <a class="el" href="classev_1_1ParseNode.html#a50b8b076e4ff3895f9716185c392a9c6">EqualOp()</a>, and <a class="el" href="structev_1_1ParseNode_1_1LessOp.html#a4946065b4be1455f5ff8de3e0604e53b">ev::ParseNode::LessOp::operator()()</a>.</p>

</div>
</div>
<a id="a8e530a7def720627e7eb03019880211b" name="a8e530a7def720627e7eb03019880211b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e530a7def720627e7eb03019880211b">&#9670;&nbsp;</a></span>GetLeft()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classev_1_1ParseNode.html">ParseNode</a> * ev::ParseNode::GetLeft </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the left branch child node of this node. </p>
<dl class="section return"><dt>Returns</dt><dd>Child node on the left branch or NULL if there is no left child. </dd></dl>

<p class="reference">References <a class="el" href="classev_1_1ParseNode.html#a41d2a504af18d57605f86ca2e39fdf98">m_left</a>.</p>

<p class="reference">Referenced by <a class="el" href="namespaceev.html#a05cec3f506b3b5ba7a41a86ce69dd2f6">ev::operator&lt;&lt;()</a>.</p>

</div>
</div>
<a id="a121cd27ac3fc7845beb169d746e4fd3d" name="a121cd27ac3fc7845beb169d746e4fd3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a121cd27ac3fc7845beb169d746e4fd3d">&#9670;&nbsp;</a></span>GetRight() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classev_1_1ParseNode.html">ParseNode</a> * ev::ParseNode::GetRight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the right branch child node of this node. </p>
<dl class="section return"><dt>Returns</dt><dd>Child node on the right branch or NULL if there is no right child. </dd></dl>

<p class="reference">References <a class="el" href="classev_1_1ParseNode.html#a0f60fc8a42bd62e2e8fa9d77be0eaee1">m_right</a>.</p>

</div>
</div>
<a id="a18306cd056264f5a5f7242dd93eb57de" name="a18306cd056264f5a5f7242dd93eb57de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18306cd056264f5a5f7242dd93eb57de">&#9670;&nbsp;</a></span>GetRight() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classev_1_1ParseNode.html">ParseNode</a> * ev::ParseNode::GetRight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the right branch child node of this node. </p>
<dl class="section return"><dt>Returns</dt><dd>Child node on the right branch or NULL if there is no right child. </dd></dl>

<p class="reference">References <a class="el" href="classev_1_1ParseNode.html#a0f60fc8a42bd62e2e8fa9d77be0eaee1">m_right</a>.</p>

<p class="reference">Referenced by <a class="el" href="classev_1_1DFA.html#aa0c6f2f5cf6f58b2bf2f92ad15cda426">ev::DFA::BuildParseTree()</a>, and <a class="el" href="namespaceev.html#a05cec3f506b3b5ba7a41a86ce69dd2f6">ev::operator&lt;&lt;()</a>.</p>

</div>
</div>
<a id="a9a3cba74a4c368f215fd3d6d5ff928ab" name="a9a3cba74a4c368f215fd3d6d5ff928ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a3cba74a4c368f215fd3d6d5ff928ab">&#9670;&nbsp;</a></span>GetSymbol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceev.html#a6efc98031badec1ea51620e17b011892">EVString</a> ev::ParseNode::GetSymbol </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the input symbol for this parse node. </p>
<dl class="section return"><dt>Returns</dt><dd>Input symbol for this parse node. </dd></dl>

<p class="reference">References <a class="el" href="classev_1_1ParseNode.html#a52c14d1e491c8ae7b92a8fc3d061aba2">m_symbol</a>.</p>

<p class="reference">Referenced by <a class="el" href="namespaceev.html#a05cec3f506b3b5ba7a41a86ce69dd2f6">ev::operator&lt;&lt;()</a>.</p>

</div>
</div>
<a id="a29416f4a095efa92cf20740539dc855f" name="a29416f4a095efa92cf20740539dc855f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29416f4a095efa92cf20740539dc855f">&#9670;&nbsp;</a></span>GetSymbolSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParseNode::GetSymbolSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceev.html#ae2a90caa1b9395bf42edb2f451535c84">SymbolSet</a> &amp;&#160;</td>
          <td class="paramname"><em>symbols</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills the specified set with the input symbols for the parse tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">symbols</td><td>[out] Set to be filled with the input symbols. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classev_1_1ParseNode.html#a29416f4a095efa92cf20740539dc855f">GetSymbolSet()</a>, <a class="el" href="classev_1_1ParseNode.html#a41d2a504af18d57605f86ca2e39fdf98">m_left</a>, <a class="el" href="classev_1_1ParseNode.html#a0f60fc8a42bd62e2e8fa9d77be0eaee1">m_right</a>, and <a class="el" href="classev_1_1ParseNode.html#a52c14d1e491c8ae7b92a8fc3d061aba2">m_symbol</a>.</p>

<p class="reference">Referenced by <a class="el" href="classev_1_1DFA.html#a71e4eab1eda1338b96b160dc03e89e3a">ev::DFA::BuildComplexDFA()</a>, <a class="el" href="classev_1_1ParseNode.html#a29416f4a095efa92cf20740539dc855f">GetSymbolSet()</a>, and <a class="el" href="namespaceev.html#a05cec3f506b3b5ba7a41a86ce69dd2f6">ev::operator&lt;&lt;()</a>.</p>

</div>
</div>
<a id="aa02d149c0e755b9206a1d7a3fe88ec12" name="aa02d149c0e755b9206a1d7a3fe88ec12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa02d149c0e755b9206a1d7a3fe88ec12">&#9670;&nbsp;</a></span>GetType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classev_1_1ParseNode.html#a5033886db86b646a9ac1f20d8ff37dcb">Type</a> ev::ParseNode::GetType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the type of the parse node. </p>
<dl class="section return"><dt>Returns</dt><dd>Parse node type. </dd></dl>

<p class="reference">References <a class="el" href="classev_1_1ParseNode.html#a5eb6da4a1d7ef54aad3d702e1478674c">m_type</a>.</p>

<p class="reference">Referenced by <a class="el" href="namespaceev.html#a05cec3f506b3b5ba7a41a86ce69dd2f6">ev::operator&lt;&lt;()</a>.</p>

</div>
</div>
<a id="ac4a71198378973cbfa81e93db4206550" name="ac4a71198378973cbfa81e93db4206550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4a71198378973cbfa81e93db4206550">&#9670;&nbsp;</a></span>HaveLeft()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ev::ParseNode::HaveLeft </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether this node has a child on its left branch. </p>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if a child node exists on the left branch. </dd></dl>

<p class="reference">References <a class="el" href="classev_1_1ParseNode.html#a41d2a504af18d57605f86ca2e39fdf98">m_left</a>.</p>

<p class="reference">Referenced by <a class="el" href="classev_1_1DFA.html#aa0c6f2f5cf6f58b2bf2f92ad15cda426">ev::DFA::BuildParseTree()</a>, and <a class="el" href="namespaceev.html#a05cec3f506b3b5ba7a41a86ce69dd2f6">ev::operator&lt;&lt;()</a>.</p>

</div>
</div>
<a id="a7eddf65d3e9d8cb326f8bcc7308bf47f" name="a7eddf65d3e9d8cb326f8bcc7308bf47f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eddf65d3e9d8cb326f8bcc7308bf47f">&#9670;&nbsp;</a></span>HaveRight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ev::ParseNode::HaveRight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether this node has a child on its right branch. </p>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if a child node exists on the right branch. </dd></dl>

<p class="reference">References <a class="el" href="classev_1_1ParseNode.html#a0f60fc8a42bd62e2e8fa9d77be0eaee1">m_right</a>.</p>

<p class="reference">Referenced by <a class="el" href="classev_1_1DFA.html#aa0c6f2f5cf6f58b2bf2f92ad15cda426">ev::DFA::BuildParseTree()</a>, and <a class="el" href="namespaceev.html#a05cec3f506b3b5ba7a41a86ce69dd2f6">ev::operator&lt;&lt;()</a>.</p>

</div>
</div>
<a id="a0430dd0dcbbb5111756bce2e0b759b56" name="a0430dd0dcbbb5111756bce2e0b759b56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0430dd0dcbbb5111756bce2e0b759b56">&#9670;&nbsp;</a></span>IsChoice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ev::ParseNode::IsChoice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether the node is an OR'd choice node. </p>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the node is an OR'd choice node. </dd></dl>

<p class="reference">References <a class="el" href="classev_1_1ParseNode.html#a5033886db86b646a9ac1f20d8ff37dcba8321db25fae1552e3d91a8fc63174d85">Choice</a>, and <a class="el" href="classev_1_1ParseNode.html#a5eb6da4a1d7ef54aad3d702e1478674c">m_type</a>.</p>

<p class="reference">Referenced by <a class="el" href="classev_1_1DFA.html#aa0c6f2f5cf6f58b2bf2f92ad15cda426">ev::DFA::BuildParseTree()</a>, <a class="el" href="classev_1_1ParseNode.html#a043aec49a1c2e543c546c9cd72d6cc61">Firstpos()</a>, <a class="el" href="classev_1_1ParseNode.html#a518da96b98058bcb0b65f156ec7d1f92">Lastpos()</a>, and <a class="el" href="classev_1_1ParseNode.html#ad8f27689dc35d3b06237616cbb4cc205">Nullable()</a>.</p>

</div>
</div>
<a id="ae0c347d9c9388e25abae76d17339ef9b" name="ae0c347d9c9388e25abae76d17339ef9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0c347d9c9388e25abae76d17339ef9b">&#9670;&nbsp;</a></span>IsEnd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ev::ParseNode::IsEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether the node is a terminal node. </p>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if node is a terminal node. </dd></dl>

<p class="reference">References <a class="el" href="classev_1_1ParseNode.html#a5033886db86b646a9ac1f20d8ff37dcbaffc2ef17f08dffb49931ae492115eec4">End</a>, and <a class="el" href="classev_1_1ParseNode.html#a5eb6da4a1d7ef54aad3d702e1478674c">m_type</a>.</p>

</div>
</div>
<a id="a6e192532cdf2b0f540d11c45cd534fe7" name="a6e192532cdf2b0f540d11c45cd534fe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e192532cdf2b0f540d11c45cd534fe7">&#9670;&nbsp;</a></span>IsEpsilon()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ev::ParseNode::IsEpsilon </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether the node is an any input node. </p>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the node is an any input node. </dd></dl>

<p class="reference">References <a class="el" href="classev_1_1ParseNode.html#a5033886db86b646a9ac1f20d8ff37dcba571be90a20298fd4ca9b33113caefb06">Epsilon</a>, and <a class="el" href="classev_1_1ParseNode.html#a5eb6da4a1d7ef54aad3d702e1478674c">m_type</a>.</p>

<p class="reference">Referenced by <a class="el" href="classev_1_1DFA.html#aa0c6f2f5cf6f58b2bf2f92ad15cda426">ev::DFA::BuildParseTree()</a>, <a class="el" href="classev_1_1ParseNode.html#a043aec49a1c2e543c546c9cd72d6cc61">Firstpos()</a>, <a class="el" href="classev_1_1ParseNode.html#a518da96b98058bcb0b65f156ec7d1f92">Lastpos()</a>, and <a class="el" href="classev_1_1ParseNode.html#ad8f27689dc35d3b06237616cbb4cc205">Nullable()</a>.</p>

</div>
</div>
<a id="ae6e8e9459da88cb7adcfc2eb61584dfd" name="ae6e8e9459da88cb7adcfc2eb61584dfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6e8e9459da88cb7adcfc2eb61584dfd">&#9670;&nbsp;</a></span>IsName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ev::ParseNode::IsName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether the node contains an element name. </p>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the node contains an element name. </dd></dl>

<p class="reference">References <a class="el" href="classev_1_1ParseNode.html#a5eb6da4a1d7ef54aad3d702e1478674c">m_type</a>, and <a class="el" href="classev_1_1ParseNode.html#a5033886db86b646a9ac1f20d8ff37dcbac59f55ecc129026bd3f81d10e103c787">Name</a>.</p>

</div>
</div>
<a id="a22f145091ed8fcf6b0a1f31f99f730de" name="a22f145091ed8fcf6b0a1f31f99f730de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22f145091ed8fcf6b0a1f31f99f730de">&#9670;&nbsp;</a></span>IsOpt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ev::ParseNode::IsOpt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether the cardinality of the node is zero or one. </p>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the cardinality of the node is zero or one. </dd></dl>

<p class="reference">References <a class="el" href="classev_1_1ParseNode.html#a5eb6da4a1d7ef54aad3d702e1478674c">m_type</a>, and <a class="el" href="classev_1_1ParseNode.html#a5033886db86b646a9ac1f20d8ff37dcba428ec16d0c0757c93debc2fd1db70515">Opt</a>.</p>

<p class="reference">Referenced by <a class="el" href="classev_1_1ParseNode.html#a043aec49a1c2e543c546c9cd72d6cc61">Firstpos()</a>, <a class="el" href="classev_1_1ParseNode.html#a518da96b98058bcb0b65f156ec7d1f92">Lastpos()</a>, and <a class="el" href="classev_1_1ParseNode.html#ad8f27689dc35d3b06237616cbb4cc205">Nullable()</a>.</p>

</div>
</div>
<a id="adcd6f364e6712231939f92e48e90b5ee" name="adcd6f364e6712231939f92e48e90b5ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcd6f364e6712231939f92e48e90b5ee">&#9670;&nbsp;</a></span>IsPlus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ev::ParseNode::IsPlus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether the cardinality of the node is one or more. </p>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the cardinality of the node is one or more. </dd></dl>

<p class="reference">References <a class="el" href="classev_1_1ParseNode.html#a5eb6da4a1d7ef54aad3d702e1478674c">m_type</a>, and <a class="el" href="classev_1_1ParseNode.html#a5033886db86b646a9ac1f20d8ff37dcba62c057b0e6b727223f79d2ffacb59f91">Plus</a>.</p>

<p class="reference">Referenced by <a class="el" href="classev_1_1ParseNode.html#a043aec49a1c2e543c546c9cd72d6cc61">Firstpos()</a>, <a class="el" href="classev_1_1ParseNode.html#a5c7333bbbb36c5d795f11195a7d67dae">Followpos()</a>, and <a class="el" href="classev_1_1ParseNode.html#a518da96b98058bcb0b65f156ec7d1f92">Lastpos()</a>.</p>

</div>
</div>
<a id="a7943bf5f0dc0a2977ea73f65c3e5e88f" name="a7943bf5f0dc0a2977ea73f65c3e5e88f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7943bf5f0dc0a2977ea73f65c3e5e88f">&#9670;&nbsp;</a></span>IsRep()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ev::ParseNode::IsRep </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether the cardinality of the node is zero of more. </p>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the cardinality of the node is zero or more. </dd></dl>

<p class="reference">References <a class="el" href="classev_1_1ParseNode.html#a5eb6da4a1d7ef54aad3d702e1478674c">m_type</a>, and <a class="el" href="classev_1_1ParseNode.html#a5033886db86b646a9ac1f20d8ff37dcba4c2237d82f94032a6d2ca15490af4e17">Rep</a>.</p>

<p class="reference">Referenced by <a class="el" href="classev_1_1ParseNode.html#a043aec49a1c2e543c546c9cd72d6cc61">Firstpos()</a>, <a class="el" href="classev_1_1ParseNode.html#a5c7333bbbb36c5d795f11195a7d67dae">Followpos()</a>, <a class="el" href="classev_1_1ParseNode.html#a518da96b98058bcb0b65f156ec7d1f92">Lastpos()</a>, and <a class="el" href="classev_1_1ParseNode.html#ad8f27689dc35d3b06237616cbb4cc205">Nullable()</a>.</p>

</div>
</div>
<a id="a00c78f9383bfe16f2b98888e551611c0" name="a00c78f9383bfe16f2b98888e551611c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00c78f9383bfe16f2b98888e551611c0">&#9670;&nbsp;</a></span>IsSeq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ev::ParseNode::IsSeq </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether the node is a sequence node. </p>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the node is a sequence node. </dd></dl>

<p class="reference">References <a class="el" href="classev_1_1ParseNode.html#a5eb6da4a1d7ef54aad3d702e1478674c">m_type</a>, and <a class="el" href="classev_1_1ParseNode.html#a5033886db86b646a9ac1f20d8ff37dcba764ec27bdd978f3d500d6c724dc7aed0">Seq</a>.</p>

<p class="reference">Referenced by <a class="el" href="classev_1_1DFA.html#aa0c6f2f5cf6f58b2bf2f92ad15cda426">ev::DFA::BuildParseTree()</a>, <a class="el" href="classev_1_1ParseNode.html#a043aec49a1c2e543c546c9cd72d6cc61">Firstpos()</a>, <a class="el" href="classev_1_1ParseNode.html#a5c7333bbbb36c5d795f11195a7d67dae">Followpos()</a>, <a class="el" href="classev_1_1ParseNode.html#a518da96b98058bcb0b65f156ec7d1f92">Lastpos()</a>, and <a class="el" href="classev_1_1ParseNode.html#ad8f27689dc35d3b06237616cbb4cc205">Nullable()</a>.</p>

</div>
</div>
<a id="a44a46bc16d660ff09e8649a1ccb9161f" name="a44a46bc16d660ff09e8649a1ccb9161f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44a46bc16d660ff09e8649a1ccb9161f">&#9670;&nbsp;</a></span>SetSymbol() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ev::ParseNode::SetSymbol </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceev.html#a6efc98031badec1ea51620e17b011892">EVString</a> &amp;&#160;</td>
          <td class="paramname"><em>symbol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the input symbol for this parse node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">symbol</td><td>[in] Input symbol for the parse node. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classev_1_1ParseNode.html#a52c14d1e491c8ae7b92a8fc3d061aba2">m_symbol</a>.</p>

</div>
</div>
<a id="a9d15e193e545b517398791b8fd97642c" name="a9d15e193e545b517398791b8fd97642c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d15e193e545b517398791b8fd97642c">&#9670;&nbsp;</a></span>SetSymbol() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ev::ParseNode::SetSymbol </td>
          <td>(</td>
          <td class="paramtype">const XML_Char *&#160;</td>
          <td class="paramname"><em>symbol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the input symbol for this parse node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">symbol</td><td>[in] Input symbol for the parse node. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classev_1_1ParseNode.html#a52c14d1e491c8ae7b92a8fc3d061aba2">m_symbol</a>.</p>

<p class="reference">Referenced by <a class="el" href="classev_1_1DFA.html#aa0c6f2f5cf6f58b2bf2f92ad15cda426">ev::DFA::BuildParseTree()</a>.</p>

</div>
</div>
<a id="a327f32856c218056887aac463f01fee0" name="a327f32856c218056887aac463f01fee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a327f32856c218056887aac463f01fee0">&#9670;&nbsp;</a></span>Union()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void ev::ParseNode::Union </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classev_1_1ParseNode.html#a2f2bac801675232374915968e477770a">NodeSet</a> &amp;&#160;</td>
          <td class="paramname"><em>set1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classev_1_1ParseNode.html#a2f2bac801675232374915968e477770a">NodeSet</a> &amp;&#160;</td>
          <td class="paramname"><em>set2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a set union on the two specified sets of nodes. </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ set_1 = set_1 \cup set_2 \]" src="form_1.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set1</td><td>[in, out] First set of the union. </td></tr>
    <tr><td class="paramname">set2</td><td>[in] Second set of the union. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="classev_1_1DFA.html#a71e4eab1eda1338b96b160dc03e89e3a">ev::DFA::BuildComplexDFA()</a>, <a class="el" href="classev_1_1ParseNode.html#a043aec49a1c2e543c546c9cd72d6cc61">Firstpos()</a>, <a class="el" href="classev_1_1ParseNode.html#a5c7333bbbb36c5d795f11195a7d67dae">Followpos()</a>, and <a class="el" href="classev_1_1ParseNode.html#a518da96b98058bcb0b65f156ec7d1f92">Lastpos()</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a047268c9eb667741446988964484d934" name="a047268c9eb667741446988964484d934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a047268c9eb667741446988964484d934">&#9670;&nbsp;</a></span>operator&lt;&lt;</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceev.html#a4743eb632c73d36a5ebd732f402db521">EVOstream</a> &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceev.html#a4743eb632c73d36a5ebd732f402db521">EVOstream</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classev_1_1ParseNode.html">ParseNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Output stream operator for a parse node. </p>
<p >Used to dump the state of the parse node to the specified output stream for debugging purposes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>[in] Output stream. </td></tr>
    <tr><td class="paramname">node</td><td>[in] Parse node to output.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Output stream. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>exval.cpp</li>
</ul>
</div><!-- contents -->
<hr size="1">
<address style="align: right;"><small>
Generated on Thu Mar 24 2022 17:33:59 for Meazure by <a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0>
</a> 1.9.3</small></address>
<address style="align: right;"><small>
Copyright 2011 C Thing Software
</small></address>
</body>
</html>
